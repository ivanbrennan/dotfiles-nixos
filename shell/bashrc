#!/bin/bash

# This file is sourced when Bash is run in an interactive shell. It holds
# functions, aliases, etc. that are specific to interactive shell usage.

# ::::::::: CDPATH :::::::::::::::::::::::::::
{
  # DON'T EXPORT CDPATH, it can screw up scripts.
  CDPATH=".:~/Development:~/Development/resources:~"
}

# ::::::::: Colors :::::::::::::::::::::::::::
{
  [ -f ~/.ansi_colors ] && . ~/.ansi_colors

  export THEME=light
}

# ::::::::: Prompt :::::::::::::::::::::::::::
{
  build_prompt() {
    export PS1="╭${BRIGHT_BLUE}\u${NORMAL}·${BRIGHT_BLUE}\W${NORMAL}\$(grb_git_prompt)${NORMAL}\n╰ဝ "
    export PS2=" ❯ "
    export PS4=" + "
  }

  grb_git_prompt() {
    if [ -n "$(__gitdir)" ]; then
      local color="$(git_branch_color)"

      # __git_ps1 inserts the current git branch where %s is
      echo " $(__git_ps1 "(${color}%s${NORMAL})")"
    fi
  }

  git_branch_color() {
    local minutes="$(minutes_since_last_commit)"

    if [ -n "$minutes" ]; then
      echo "$(minutes_color minutes)"
    elif [[ "$THEME" == 'dark' ]]; then
      echo $WHITE
    else
      echo $BLACK
    fi
  }

  minutes_since_last_commit() {
    local now=$(date +%s)
    local last_commit=$(git log --pretty=format:'%at' -1 2>/dev/null)

    if [ "$?" -eq 0 ]; then
      echo $(( (now - last_commit) / 60 ))
    fi
  }

  minutes_color() {
    if [ -z "$1" ]; then
      return
    elif [[ "$1" -gt 30 ]]; then
      echo "${RED}"
    elif [[  "$1" -gt 10  ]]; then
      echo "${YELLOW}"
    else
      echo "${GREEN}"
    fi
  }

  build_prompt
}

# ::::::::: Sources ::::::::::::::::::::::::::
{
  files=(~/.bashrc.local
         ~/.bash_aliases
         ~/.bash_functions)

  for file in "${files[@]}"; do
    [ -r "$file" ] && . "$file"
  done
}

# ::::::::: Shell Options ::::::::::::::::::::
{
  shopt -s histappend cmdhist lithist

  # If shell is interactive, disable START/STOP output control.
  # This allows Ctrl-S to trigger i-search.
  if [[ $- = *i* ]]; then
    # -ixon : Disable START/STOP output control.
    # This allows Ctrl-S to trigger i-search.
    stty -ixon
  fi

  unset -v MAILCHECK
}

# ::::::::: History ::::::::::::::::::::::::::
{
  HISTTIMEFORMAT='%F %T '
  HISTCONTROL=erasedups:ignorespace
  HISTSIZE=10000
  HISTFILESIZE=20000
  HISTIGNORE='jobs:[fb]g:history:gst:tls'
}

# ::::::::: Completion :::::::::::::::::::::::

# Bash completion
if [ -r ~/.nix-profile/share/bash-completion/bash_completion ]; then
  . ~/.nix-profile/share/bash-completion/bash_completion
  __load_completion tmux # alias (t) doesn't trigger dynamic completion loading
fi
for f in ~/.nix-profile/etc/bash_completion.d/*; do
  [ -r "$f" ] && . "$f"
done

# Display all 2856 possibilities? Um, no thanks
shopt -s no_empty_cmd_completion

# Kubectl shell completion
[ -r ~/.kube/completion.bash.inc ] && . ~/.kube/completion.bash.inc

# minikube shell completion
[ -r ~/.minikube/completion.bash.inc ] && . ~/.minikube/completion.bash.inc

eval "$(stack --bash-completion-script stack 2>/dev/null)"

# rbenv
export PATH="$HOME/.rbenv/bin:$PATH"
export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"
if command -v rbenv > /dev/null; then eval "$(rbenv init -)"; fi
